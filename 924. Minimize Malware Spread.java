class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        Set<Integer> initialSet = new HashSet<>();
        for (int i : initial) initialSet.add(i);

        int max = 0, res = initial[0];
        for (int i : initial) {
            int tmp = bfs(i, i, graph, initialSet, new HashSet<>());
            if (tmp != -1 && tmp > max) {
                max = tmp;
                res = i;
            }
        }
        return res;
    }

    private int bfs(int cur, int inital, int[][] graph, Set<Integer> initalSet, Set<Integer> visited) {
        if (cur != inital && initalSet.contains(cur)) return -1;
        int res = 1;
        visited.add(cur);
        for (int i = 0; i < graph[cur].length; i++) {
            if (graph[cur][i] == 1 && !visited.contains(i)) {                            
                int tmp = bfs(i, inital, graph, initalSet, visited);
                if (tmp == -1) return -1;
                res += tmp;                
            }
        }
        return res;
    }
}


class Solution {
    // Use an array to contain the flag - whether the union has another malware
    private boolean containsOtherMal;

    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        Set<Integer> mals = new HashSet<>();
        for (int i : initial) mals.add(i);
        
        int max = 0; //max count for an union in the graph
        int res = initial[0];
        for (int i : initial) {
            containsOtherMal = false;
            Set<Integer> visited = new HashSet<>();
            int count = dfs(i, i, graph, visited, mals);

            // If current union has another malware, which means if we delete current node, still another malware will affect the whole union
            if (containsOtherMal) continue;

            if (count > max) {
                max = count;
                res = i;
            }
        }
        return res;
    }

    // Dfs to count how many node in current union begin from start
    int dfs(int start, int initialStart, int[][] graph, Set<Integer> visited, Set<Integer> mals) {
        if (visited.contains(start)) return 0;

        int res = 1;
        visited.add(start);
        for (int i = 0; i < graph[start].length; i++) {
            if (graph[start][i] == 1) {
                // If we found another malware that is different from the initialStart, we set the flag to true and there is no need to continue the search.
                if (initialStart != i && mals.contains(i)) {
                    containsOtherMal = true;
                    break;
                }
                res += dfs(i, initialStart, graph, visited, mals);
            }
        }
        return res;
    }
}